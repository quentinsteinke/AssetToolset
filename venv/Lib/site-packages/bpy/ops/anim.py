import sys
import typing
import bpy.types


def change_frame(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        frame: float = 0.0,
        snap: bool = False):
    ''' Interactively change the current frame number

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param frame: Frame
    :type frame: float
    :param snap: Snap
    :type snap: bool
    '''

    pass


def channel_select_keys(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        extend: bool = False):
    ''' Select all keyframes of channel under mouse

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param extend: Extend, Extend selection
    :type extend: bool
    '''

    pass


def channels_clean_empty(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Delete all empty animation data containers from visible data-blocks

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def channels_click(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        extend: bool = False,
        children_only: bool = False):
    ''' Handle mouse clicks over animation channels

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param extend: Extend Select
    :type extend: bool
    :param children_only: Select Children Only
    :type children_only: bool
    '''

    pass


def channels_collapse(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        all: bool = True):
    ''' Collapse (close) all selected expandable animation channels

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param all: All, Collapse all channels (not just selected ones)
    :type all: bool
    '''

    pass


def channels_delete(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Delete all selected animation channels

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def channels_editable_toggle(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        mode: typing.Union[str, int] = 'TOGGLE',
        type: typing.Union[str, int] = 'PROTECT'):
    ''' Toggle editability of selected channels

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param mode: Mode
    :type mode: typing.Union[str, int]
    :param type: Type
    :type type: typing.Union[str, int]
    '''

    pass


def channels_expand(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        all: bool = True):
    ''' Expand (open) all selected expandable animation channels

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param all: All, Expand all channels (not just selected ones)
    :type all: bool
    '''

    pass


def channels_fcurves_enable(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Clears 'disabled' tag from all F-Curves to get broken F-Curves working again

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def channels_group(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        name: str = "New Group"):
    ''' Add selected F-Curves to a new group

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param name: Name, Name of newly created group
    :type name: str
    '''

    pass


def channels_move(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        direction: typing.Union[str, int] = 'DOWN'):
    ''' Rearrange selected animation channels

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param direction: Direction
    :type direction: typing.Union[str, int]
    '''

    pass


def channels_rename(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Rename animation channel under mouse

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def channels_select_all(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        action: typing.Union[str, int] = 'TOGGLE'):
    ''' Toggle selection of all animation channels

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param action: Action, Selection action to execute * TOGGLE Toggle -- Toggle selection for all elements. * SELECT Select -- Select all elements. * DESELECT Deselect -- Deselect all elements. * INVERT Invert -- Invert selection of all elements.
    :type action: typing.Union[str, int]
    '''

    pass


def channels_select_box(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        xmin: int = 0,
        xmax: int = 0,
        ymin: int = 0,
        ymax: int = 0,
        wait_for_input: bool = True,
        deselect: bool = False,
        extend: bool = True):
    ''' Select all animation channels within the specified region

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param xmin: X Min
    :type xmin: int
    :param xmax: X Max
    :type xmax: int
    :param ymin: Y Min
    :type ymin: int
    :param ymax: Y Max
    :type ymax: int
    :param wait_for_input: Wait for Input
    :type wait_for_input: bool
    :param deselect: Deselect, Deselect rather than select items
    :type deselect: bool
    :param extend: Extend, Extend selection instead of deselecting everything first
    :type extend: bool
    '''

    pass


def channels_select_filter(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Start entering text which filters the set of channels shown to only include those with matching names

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def channels_setting_disable(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        mode: typing.Union[str, int] = 'DISABLE',
        type: typing.Union[str, int] = 'PROTECT'):
    ''' Disable specified setting on all selected animation channels

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param mode: Mode
    :type mode: typing.Union[str, int]
    :param type: Type
    :type type: typing.Union[str, int]
    '''

    pass


def channels_setting_enable(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        mode: typing.Union[str, int] = 'ENABLE',
        type: typing.Union[str, int] = 'PROTECT'):
    ''' Enable specified setting on all selected animation channels

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param mode: Mode
    :type mode: typing.Union[str, int]
    :param type: Type
    :type type: typing.Union[str, int]
    '''

    pass


def channels_setting_toggle(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        mode: typing.Union[str, int] = 'TOGGLE',
        type: typing.Union[str, int] = 'PROTECT'):
    ''' Toggle specified setting on all selected animation channels

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param mode: Mode
    :type mode: typing.Union[str, int]
    :param type: Type
    :type type: typing.Union[str, int]
    '''

    pass


def channels_ungroup(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Remove selected F-Curves from their current groups

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def clear_useless_actions(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        only_unused: bool = True):
    ''' Mark actions with no F-Curves for deletion after save and reload of file preserving "action libraries"

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param only_unused: Only Unused, Only unused (Fake User only) actions get considered
    :type only_unused: bool
    '''

    pass


def copy_driver_button(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Copy the driver for the highlighted button

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def driver_button_add(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Add driver for the property under the cursor

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def driver_button_edit(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Edit the drivers for the property connected represented by the highlighted button

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def driver_button_remove(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        all: bool = True):
    ''' Remove the driver(s) for the property(s) connected represented by the highlighted button

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param all: All, Delete drivers for all elements of the array
    :type all: bool
    '''

    pass


def end_frame_set(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Set the current frame as the preview or scene end frame

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def keyframe_clear_button(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        all: bool = True):
    ''' Clear all keyframes on the currently active property

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param all: All, Clear keyframes from all elements of the array
    :type all: bool
    '''

    pass


def keyframe_clear_v3d(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Remove all keyframe animation for selected objects

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def keyframe_delete(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        type: typing.Union[str, int] = 'DEFAULT'):
    ''' Delete keyframes on the current frame for all properties in the specified Keying Set

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param type: Keying Set, The Keying Set to use
    :type type: typing.Union[str, int]
    '''

    pass


def keyframe_delete_button(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        all: bool = True):
    ''' Delete current keyframe of current UI-active property

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param all: All, Delete keyframes from all elements of the array
    :type all: bool
    '''

    pass


def keyframe_delete_by_name(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        type: str = ""):
    ''' Alternate access to 'Delete Keyframe' for keymaps to use

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param type: Keying Set, The Keying Set to use
    :type type: str
    '''

    pass


def keyframe_delete_v3d(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Remove keyframes on current frame for selected objects and bones

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def keyframe_insert(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        type: typing.Union[str, int] = 'DEFAULT'):
    ''' Insert keyframes on the current frame for all properties in the specified Keying Set

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param type: Keying Set, The Keying Set to use
    :type type: typing.Union[str, int]
    '''

    pass


def keyframe_insert_button(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        all: bool = True):
    ''' Insert a keyframe for current UI-active property

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param all: All, Insert a keyframe for all element of the array
    :type all: bool
    '''

    pass


def keyframe_insert_by_name(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        type: str = ""):
    ''' Alternate access to 'Insert Keyframe' for keymaps to use

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param type: Keying Set, The Keying Set to use
    :type type: str
    '''

    pass


def keyframe_insert_menu(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        type: typing.Union[str, int] = 'DEFAULT',
        always_prompt: bool = False):
    ''' Insert Keyframes for specified Keying Set, with menu of available Keying Sets if undefined

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param type: Keying Set, The Keying Set to use
    :type type: typing.Union[str, int]
    :param always_prompt: Always Show Menu
    :type always_prompt: bool
    '''

    pass


def keying_set_active_set(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        type: typing.Union[str, int] = 'DEFAULT'):
    ''' Select a new keying set as the active one

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param type: Keying Set, The Keying Set to use
    :type type: typing.Union[str, int]
    '''

    pass


def keying_set_add(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Add a new (empty) Keying Set to the active Scene

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def keying_set_export(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        filepath: str = "",
        filter_folder: bool = True,
        filter_text: bool = True,
        filter_python: bool = True):
    ''' Export Keying Set to a python script

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param filepath: filepath
    :type filepath: str
    :param filter_folder: Filter folders
    :type filter_folder: bool
    :param filter_text: Filter text
    :type filter_text: bool
    :param filter_python: Filter python
    :type filter_python: bool
    '''

    pass


def keying_set_path_add(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Add empty path to active Keying Set

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def keying_set_path_remove(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Remove active Path from active Keying Set

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def keying_set_remove(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Remove the active Keying Set

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def keyingset_button_add(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        all: bool = True):
    ''' Add current UI-active property to current keying set

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param all: All, Add all elements of the array to a Keying Set
    :type all: bool
    '''

    pass


def keyingset_button_remove(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Remove current UI-active property from current keying set

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def paste_driver_button(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Paste the driver in the copy/paste buffer for the highlighted button

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def previewrange_clear(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Clear preview range

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def previewrange_set(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        xmin: int = 0,
        xmax: int = 0,
        ymin: int = 0,
        ymax: int = 0,
        wait_for_input: bool = True):
    ''' Interactively define frame range used for playback

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param xmin: X Min
    :type xmin: int
    :param xmax: X Max
    :type xmax: int
    :param ymin: Y Min
    :type ymin: int
    :param ymax: Y Max
    :type ymax: int
    :param wait_for_input: Wait for Input
    :type wait_for_input: bool
    '''

    pass


def start_frame_set(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Set the current frame as the preview or scene start frame

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def update_animated_transform_constraints(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        use_convert_to_radians: bool = True):
    ''' Update f-curves/drivers affecting Transform constraints (use it with files from 2.70 and earlier)

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param use_convert_to_radians: Convert to Radians, Convert f-curves/drivers affecting rotations to radians. Warning: Use this only once
    :type use_convert_to_radians: bool
    '''

    pass
