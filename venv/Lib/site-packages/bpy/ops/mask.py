import sys
import typing
import bpy.types
import bpy.ops.transform


def add_feather_vertex(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        location: typing.List[float] = (0.0, 0.0)):
    ''' Add vertex to feather

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param location: Location, Location of vertex in normalized space
    :type location: typing.List[float]
    '''

    pass


def add_feather_vertex_slide(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        MASK_OT_add_feather_vertex: 'add_feather_vertex' = None,
        MASK_OT_slide_point: 'slide_point' = None):
    ''' Add new vertex to feather and slide it

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param MASK_OT_add_feather_vertex: Add Feather Vertex, Add vertex to feather
    :type MASK_OT_add_feather_vertex: 'add_feather_vertex'
    :param MASK_OT_slide_point: Slide Point, Slide control points
    :type MASK_OT_slide_point: 'slide_point'
    '''

    pass


def add_vertex(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        location: typing.List[float] = (0.0, 0.0)):
    ''' Add vertex to active spline

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param location: Location, Location of vertex in normalized space
    :type location: typing.List[float]
    '''

    pass


def add_vertex_slide(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        MASK_OT_add_vertex: 'add_vertex' = None,
        MASK_OT_slide_point: 'slide_point' = None):
    ''' Add new vertex and slide it

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param MASK_OT_add_vertex: Add Vertex, Add vertex to active spline
    :type MASK_OT_add_vertex: 'add_vertex'
    :param MASK_OT_slide_point: Slide Point, Slide control points
    :type MASK_OT_slide_point: 'slide_point'
    '''

    pass


def copy_splines(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Copy selected splines to clipboard

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def cyclic_toggle(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Toggle cyclic for selected splines

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def delete(override_context: typing.Union[dict, 'bpy.types.Context'] = None,
           execution_context: typing.Union[str, int] = None,
           undo: bool = None):
    ''' Delete selected control points or splines

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def duplicate(override_context: typing.Union[dict, 'bpy.types.Context'] = None,
              execution_context: typing.Union[str, int] = None,
              undo: bool = None):
    ''' Duplicate selected control points and segments between them

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def duplicate_move(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        MASK_OT_duplicate: 'duplicate' = None,
        TRANSFORM_OT_translate: 'bpy.ops.transform.translate' = None):
    ''' Duplicate mask and move

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param MASK_OT_duplicate: Duplicate Mask, Duplicate selected control points and segments between them
    :type MASK_OT_duplicate: 'duplicate'
    :param TRANSFORM_OT_translate: Move, Move selected items
    :type TRANSFORM_OT_translate: 'bpy.ops.transform.translate'
    '''

    pass


def feather_weight_clear(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Reset the feather weight to zero

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def handle_type_set(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        type: typing.Union[str, int] = 'AUTO'):
    ''' Set type of handles for selected control points

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param type: Type, Spline type
    :type type: typing.Union[str, int]
    '''

    pass


def hide_view_clear(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        select: bool = True):
    ''' Reveal the layer by setting the hide flag

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param select: Select
    :type select: bool
    '''

    pass


def hide_view_set(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        unselected: bool = False):
    ''' Hide the layer by setting the hide flag

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param unselected: Unselected, Hide unselected rather than selected layers
    :type unselected: bool
    '''

    pass


def layer_move(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        direction: typing.Union[str, int] = 'UP'):
    ''' Move the active layer up/down in the list

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param direction: Direction, Direction to move the active layer
    :type direction: typing.Union[str, int]
    '''

    pass


def layer_new(override_context: typing.Union[dict, 'bpy.types.Context'] = None,
              execution_context: typing.Union[str, int] = None,
              undo: bool = None,
              *,
              name: str = ""):
    ''' Add new mask layer for masking

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param name: Name, Name of new mask layer
    :type name: str
    '''

    pass


def layer_remove(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Remove mask layer

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def new(override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        name: str = ""):
    ''' Create new mask

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param name: Name, Name of new mask
    :type name: str
    '''

    pass


def normals_make_consistent(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Recalculate the direction of selected handles

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def parent_clear(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Clear the mask's parenting

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def parent_set(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Set the mask's parenting

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def paste_splines(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Paste splines from clipboard

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def primitive_circle_add(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        size: float = 100.0,
        location: typing.List[float] = (0.0, 0.0)):
    ''' Add new circle-shaped spline

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param size: Size, Size of new circle
    :type size: float
    :param location: Location, Location of new circle
    :type location: typing.List[float]
    '''

    pass


def primitive_square_add(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        size: float = 100.0,
        location: typing.List[float] = (0.0, 0.0)):
    ''' Add new square-shaped spline

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param size: Size, Size of new circle
    :type size: float
    :param location: Location, Location of new circle
    :type location: typing.List[float]
    '''

    pass


def select(override_context: typing.Union[dict, 'bpy.types.Context'] = None,
           execution_context: typing.Union[str, int] = None,
           undo: bool = None,
           *,
           extend: bool = False,
           deselect: bool = False,
           toggle: bool = False,
           deselect_all: bool = False,
           select_passthrough: bool = False,
           location: typing.List[float] = (0.0, 0.0)):
    ''' Select spline points

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param extend: Extend, Extend selection instead of deselecting everything first
    :type extend: bool
    :param deselect: Deselect, Remove from selection
    :type deselect: bool
    :param toggle: Toggle Selection, Toggle the selection
    :type toggle: bool
    :param deselect_all: Deselect On Nothing, Deselect all when nothing under the cursor
    :type deselect_all: bool
    :param select_passthrough: Only Select Unselected, Ignore the select action when the element is already selected
    :type select_passthrough: bool
    :param location: Location, Location of vertex in normalized space
    :type location: typing.List[float]
    '''

    pass


def select_all(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        action: typing.Union[str, int] = 'TOGGLE'):
    ''' Change selection of all curve points

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param action: Action, Selection action to execute * TOGGLE Toggle -- Toggle selection for all elements. * SELECT Select -- Select all elements. * DESELECT Deselect -- Deselect all elements. * INVERT Invert -- Invert selection of all elements.
    :type action: typing.Union[str, int]
    '''

    pass


def select_box(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        xmin: int = 0,
        xmax: int = 0,
        ymin: int = 0,
        ymax: int = 0,
        wait_for_input: bool = True,
        mode: typing.Union[str, int] = 'SET'):
    ''' Select curve points using box selection

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param xmin: X Min
    :type xmin: int
    :param xmax: X Max
    :type xmax: int
    :param ymin: Y Min
    :type ymin: int
    :param ymax: Y Max
    :type ymax: int
    :param wait_for_input: Wait for Input
    :type wait_for_input: bool
    :param mode: Mode * SET Set -- Set a new selection. * ADD Extend -- Extend existing selection. * SUB Subtract -- Subtract existing selection.
    :type mode: typing.Union[str, int]
    '''

    pass


def select_circle(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        x: int = 0,
        y: int = 0,
        radius: int = 25,
        wait_for_input: bool = True,
        mode: typing.Union[str, int] = 'SET'):
    ''' Select curve points using circle selection

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param x: X
    :type x: int
    :param y: Y
    :type y: int
    :param radius: Radius
    :type radius: int
    :param wait_for_input: Wait for Input
    :type wait_for_input: bool
    :param mode: Mode * SET Set -- Set a new selection. * ADD Extend -- Extend existing selection. * SUB Subtract -- Subtract existing selection.
    :type mode: typing.Union[str, int]
    '''

    pass


def select_lasso(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        path: typing.List['bpy.types.OperatorMousePath'] = None,
        mode: typing.Union[str, int] = 'SET'):
    ''' Select curve points using lasso selection

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param path: Path
    :type path: typing.List['bpy.types.OperatorMousePath']
    :param mode: Mode * SET Set -- Set a new selection. * ADD Extend -- Extend existing selection. * SUB Subtract -- Subtract existing selection.
    :type mode: typing.Union[str, int]
    '''

    pass


def select_less(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Deselect spline points at the boundary of each selection region

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def select_linked(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Select all curve points linked to already selected ones

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def select_linked_pick(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        deselect: bool = False):
    ''' (De)select all points linked to the curve under the mouse cursor

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param deselect: Deselect
    :type deselect: bool
    '''

    pass


def select_more(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Select more spline points connected to initial selection

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def shape_key_clear(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Remove mask shape keyframe for active mask layer at the current frame

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def shape_key_feather_reset(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Reset feather weights on all selected points animation values

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def shape_key_insert(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Insert mask shape keyframe for active mask layer at the current frame

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def shape_key_rekey(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        location: bool = True,
        feather: bool = True):
    ''' Recalculate animation data on selected points for frames selected in the dopesheet

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param location: Location
    :type location: bool
    :param feather: Feather
    :type feather: bool
    '''

    pass


def slide_point(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None,
        *,
        slide_feather: bool = False,
        is_new_point: bool = False):
    ''' Slide control points

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    :param slide_feather: Slide Feather, First try to slide feather instead of vertex
    :type slide_feather: bool
    :param is_new_point: Slide New Point, Newly created vertex is being slid
    :type is_new_point: bool
    '''

    pass


def slide_spline_curvature(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Slide a point on the spline to define its curvature

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass


def switch_direction(
        override_context: typing.Union[dict, 'bpy.types.Context'] = None,
        execution_context: typing.Union[str, int] = None,
        undo: bool = None):
    ''' Switch direction of selected splines

    :type override_context: typing.Union[dict, 'bpy.types.Context']
    :type execution_context: typing.Union[str, int]
    :type undo: bool
    '''

    pass
